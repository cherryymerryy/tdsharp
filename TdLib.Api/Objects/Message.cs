using System;
using Newtonsoft.Json;

namespace TdLib
{
    /// <summary>
    /// Autogenerated TDLib APIs
    /// </summary>
    public static partial class TdApi
    {
        /// <summary>
        /// Describes a message
        /// </summary>
        public partial class Message : Object
        {
            /// <summary>
            /// Data type for serialization
            /// </summary>
            [JsonProperty("@type")]
            public override string DataType { get; set; } = "message";

            /// <summary>
            /// Extra data attached to the object
            /// </summary>
            [JsonProperty("@extra")]
            public override string Extra { get; set; }

            /// <summary>
            /// Message identifier; unique for the chat to which the message belongs
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("id")]
            public long Id { get; set; }

            /// <summary>
            /// Identifier of the sender of the message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sender_id")]
            public MessageSender SenderId { get; set; }

            /// <summary>
            /// Chat identifier
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("chat_id")]
            public long ChatId { get; set; }

            /// <summary>
            /// The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("sending_state")]
            public MessageSendingState SendingState { get; set; }

            /// <summary>
            /// The scheduling state of the message; may be null if the message isn't scheduled
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("scheduling_state")]
            public MessageSchedulingState SchedulingState { get; set; }

            /// <summary>
            /// True, if the message is outgoing
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_outgoing")]
            public bool IsOutgoing { get; set; }

            /// <summary>
            /// True, if the message is pinned
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_pinned")]
            public bool IsPinned { get; set; }

            /// <summary>
            /// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_edited")]
            public bool CanBeEdited { get; set; }

            /// <summary>
            /// True, if the message can be forwarded
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_forwarded")]
            public bool CanBeForwarded { get; set; }

            /// <summary>
            /// True, if the message can be replied in another chat or topic
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_replied_in_another_chat")]
            public bool CanBeRepliedInAnotherChat { get; set; }

            /// <summary>
            /// True, if content of the message can be saved locally or copied
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_saved")]
            public bool CanBeSaved { get; set; }

            /// <summary>
            /// True, if the message can be deleted only for the current user while other users will continue to see it
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_deleted_only_for_self")]
            public bool CanBeDeletedOnlyForSelf { get; set; }

            /// <summary>
            /// True, if the message can be deleted for all users
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_be_deleted_for_all_users")]
            public bool CanBeDeletedForAllUsers { get; set; }

            /// <summary>
            /// True, if the list of added reactions is available through getMessageAddedReactions
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_get_added_reactions")]
            public bool CanGetAddedReactions { get; set; }

            /// <summary>
            /// True, if the message statistics are available through getMessageStatistics
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_get_statistics")]
            public bool CanGetStatistics { get; set; }

            /// <summary>
            /// True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_get_message_thread")]
            public bool CanGetMessageThread { get; set; }

            /// <summary>
            /// True, if chat members already viewed the message can be received through getMessageViewers
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_get_viewers")]
            public bool CanGetViewers { get; set; }

            /// <summary>
            /// True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_get_media_timestamp_links")]
            public bool CanGetMediaTimestampLinks { get; set; }

            /// <summary>
            /// True, if reactions on the message can be reported through reportMessageReactions
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("can_report_reactions")]
            public bool CanReportReactions { get; set; }

            /// <summary>
            /// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("has_timestamped_media")]
            public bool HasTimestampedMedia { get; set; }

            /// <summary>
            /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_channel_post")]
            public bool IsChannelPost { get; set; }

            /// <summary>
            /// True, if the message is a forum topic message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("is_topic_message")]
            public bool IsTopicMessage { get; set; }

            /// <summary>
            /// True, if the message contains an unread mention for the current user
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("contains_unread_mention")]
            public bool ContainsUnreadMention { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("date")]
            public int Date { get; set; }

            /// <summary>
            /// Point in time (Unix timestamp) when the message was last edited
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("edit_date")]
            public int EditDate { get; set; }

            /// <summary>
            /// Information about the initial message sender; may be null if none or unknown
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("forward_info")]
            public MessageForwardInfo ForwardInfo { get; set; }

            /// <summary>
            /// Information about the initial message for messages created with importMessages; may be null if the message isn't imported
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("import_info")]
            public MessageImportInfo ImportInfo { get; set; }

            /// <summary>
            /// Information about interactions with the message; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("interaction_info")]
            public MessageInteractionInfo InteractionInfo { get; set; }

            /// <summary>
            /// Information about unread reactions added to the message
            /// </summary>
            [JsonProperty("unread_reactions", ItemConverterType = typeof(Converter))]
            public UnreadReaction[] UnreadReactions { get; set; }

            /// <summary>
            /// Information about the message or the story this message is replying to; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_to")]
            public MessageReplyTo ReplyTo { get; set; }

            /// <summary>
            /// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("message_thread_id")]
            public long MessageThreadId { get; set; }

            /// <summary>
            /// The message's self-destruct type; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("self_destruct_type")]
            public MessageSelfDestructType SelfDestructType { get; set; }

            /// <summary>
            /// Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("self_destruct_in")]
            public double? SelfDestructIn { get; set; }

            /// <summary>
            /// Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("auto_delete_in")]
            public double? AutoDeleteIn { get; set; }

            /// <summary>
            /// If non-zero, the user identifier of the bot through which this message was sent
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("via_bot_user_id")]
            public long ViaBotUserId { get; set; }

            /// <summary>
            /// For channel posts and anonymous group messages, optional author signature
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("author_signature")]
            public string AuthorSignature { get; set; }

            /// <summary>
            /// Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
            /// </summary>
            [JsonConverter(typeof(Converter.Int64))]
            [JsonProperty("media_album_id")]
            public long MediaAlbumId { get; set; }

            /// <summary>
            /// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("restriction_reason")]
            public string RestrictionReason { get; set; }

            /// <summary>
            /// Content of the message
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("content")]
            public MessageContent Content { get; set; }

            /// <summary>
            /// Reply markup for the message; may be null if none
            /// </summary>
            [JsonConverter(typeof(Converter))]
            [JsonProperty("reply_markup")]
            public ReplyMarkup ReplyMarkup { get; set; }
        }
    }
}